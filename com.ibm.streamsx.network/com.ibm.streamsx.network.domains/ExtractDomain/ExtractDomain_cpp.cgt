<%
## Copyright (C) 2017  International Business Machines Corporation
## All Rights Reserved
%>

/*
 */

#include <string>
#include <arpa/inet.h>
#include "NetworkResources.h"
#include <atomic>

#define EXTRACT_DOMAIN "EXTRACT_DOMAIN"

using namespace SPL;
using namespace std;

<%
unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . "/../impl/bin";
require CodeGenX;

# These fragments of Perl code get strings from the operator's declaration
# in the SPL source code for use in generating C/C++ code for the operator's
# implementation below

# get the name of this operator's template
my $myOperatorKind = $model->getContext()->getKind();

# get Perl objects for input and output ports
my $inputPort0 = $model->getInputPortAt(0);
my $inTupleType0 = $inputPort0->getCppTupleType();
my $inputPort1 = $model->getInputPortAt(1);

my $outputPort = $model->getOutputPortAt(0);
my $outTupleType = $outputPort->getCppTupleType();

# Verify the main input port and output port are of the same type.
# They need to be!
SPL::CodeGen::exitln(SPL::Msg::STDTK_OUTPUT_SCHEMA_NOT_MATCHING_INPUT(0, 0),
                         $inputPort0->getSourceLocation()) if ($inTupleType0 ne $outTupleType);

my $inputPort1CppName = $inputPort1->getCppTupleName();
my $tldAttribute = $inputPort1->getAttributeAt(0)->getName();

# get C++ expressions for getting the values of this operator's parameters
my $inputFQDNAttrParamCppValue = $model->getParameterByName("inputFQDNAttr")->getValueAt(0)->getCppExpression();

my $outputDomainAttr = $model->getParameterByName("outputDomainAttr")->getValueAt(0)->getSPLExpression();
# remove the stream name from the attribute
$outputDomainAttr =~ s/^.*\.//;

my $blankOnInvalid = $model->getParameterByName("blankOnInvalidTLD");
$blankOnInvalid = $blankOnInvalid ? $blankOnInvalid->getValueAt(0)->getSPLExpression() eq "true" : undef;
my $metricsInterval = $model->getParameterByName("metricsInterval") ? $model->getParameterByName("metricsInterval")->getValueAt(0)->getCppExpression() : "10.0";

%>

<%SPL::CodeGen::implementationPrologue($model);%>


#define TIMEDIFF(b,a) \
    ( (uint64_t)((long)((b).tv_sec - (a).tv_sec)*1000000000l + ((b).tv_nsec - (a).tv_nsec)) )

#ifdef MEASURE_TIMINGS_EXTRACTDOMAIN
#define STAMPTIME(name) \
    struct timespec name; \
    clock_gettime(CLOCK_MONOTONIC, &name)
#define PREPTIME(name) \
    struct timespec name
#define STAMPTIME_PREPPED(name) \
    clock_gettime(CLOCK_MONOTONIC, &name)
#else
#define STAMPTIME(name)
#define PREPTIME(name)
#define STAMPTIME_PREPPED(name)
#endif

// Constructor
MY_OPERATOR::MY_OPERATOR() {
    tldsRSel_ = 0;
    tldsWSel_ = 1;
    firstListLoaded_ = false;

    tlds_[0] = new TLDSet();
    tlds_[1] = new TLDSet();
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() {
    delete tlds_[0];
    delete tlds_[1];
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() {
    // Notifies that all ports are ready. No tuples should be submitted before
    // this. Source operators can use this method to spawn threads.

    createThreads(1); // Create metrics thread
}

// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() {
    // This is an asynchronous call
    traceStats();
}

// Processing for source and threaded operators
void MY_OPERATOR::process(uint32_t idx)
{
    SPLAPPTRC(L_TRACE, "process(thread "<<idx<<"): entered", EXTRACT_DOMAIN);


    ProcessingElement &pe = getPE();

    double metricsInterval = <%=$metricsInterval%>;

    double lastMetricsTime = SPL::Functions::Time::getTimestampInSecs();

    // A typical implementation will loop until shutdown
    while(!pe.getShutdownRequested()) {

        // Let more data accumulate
        double targetTime = lastMetricsTime + metricsInterval;
        double now = SPL::Functions::Time::getTimestampInSecs();
        pe.blockUntilShutdownRequest(targetTime - now);
        lastMetricsTime = targetTime;

        updateMetrics();
    }

    updateMetrics();

    SPLAPPTRC(L_TRACE, "process(thread "<<idx<<"): exiting", EXTRACT_DOMAIN);
}

void MY_OPERATOR::updateMetrics()
{
    // Create the user-defined metrics
    OperatorMetrics& opm = getContext().getMetrics();

    // expose the operator's statistics as metrics
    opm.getCustomMetricByName("sent_tuple_latency").setValue(time_total_added.load(std::memory_order_relaxed));
    opm.getCustomMetricByName("downstream_latency").setValue(time_submit.load(std::memory_order_relaxed));
}

void MY_OPERATOR::traceStats() {

#ifdef MEASURE_TIMINGS_EXTRACTDOMAIN
    SPLAPPTRC(L_ERROR, "count_processed " << count_processed << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "count_no_tld_found " << count_no_tld_found << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "count_labels_no_tld_found " << count_labels_no_tld_found << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "count_labels " << count_labels << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_total_added " << time_total_added << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_preprep " << time_preprep << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_lock " << time_lock << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_wait_first " << time_wait_first << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_total_kernel_found " << time_total_kernel_found << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_total_kernel_not_found " << time_total_kernel_not_found << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_set_lookup " << time_set_lookup << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_find_label " << time_find_label << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_unlock " << time_unlock << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_postprep " << time_postprep << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_submit " << time_submit << " " << count_dumps, EXTRACT_DOMAIN);
    SPLAPPTRC(L_ERROR, "time_intercall " << time_intercall << " " << count_dumps, EXTRACT_DOMAIN);
    ++count_dumps;
#endif
}

// Tuple processing for mutating ports
void MY_OPERATOR::process(Tuple & tuple, uint32_t port) {
    SPLAPPTRC(L_TRACE, "entering <%=$myOperatorKind%> process() mutating.", EXTRACT_DOMAIN);

    if(port == 0) {
        struct timespec ts_start;
        clock_gettime(CLOCK_MONOTONIC, &ts_start);
        struct timespec ts_presubmit;
        struct timespec ts_end;

        IPort0Type& iport$0 = (IPort0Type &)tuple;

        bool had_to_wait = false;

#ifdef MEASURE_TIMINGS_EXTRACTDOMAIN
        uint64_t labels_searched = 0;
        uint64_t lookup_time = 0;
        uint64_t scan_time = 0;
#endif
        PREPTIME(ts_prelock);
        PREPTIME(ts_postlock);
        PREPTIME(ts_prekernel);
        PREPTIME(ts_loopstart);
        PREPTIME(ts_midloop);
        PREPTIME(ts_postkernel);
        PREPTIME(ts_postunlock);

        std::string fqdn = <%=$inputFQDNAttrParamCppValue%>;
        SPLAPPTRC(L_TRACE, "Process mutating, port 0: " << fqdn, EXTRACT_DOMAIN);

        // Switch it to lower case, since that's how the TLDs will be
        for(size_t i = 0; i < fqdn.length(); ++i) {
            fqdn[i] = ::tolower(fqdn[i]);
        }


        // search the input tuple's FQDN string looking for the longest suffix that matches any TLD.
        // Back up one label, and that's what gets copied to the output domain field.
        // If nothing matches, set the output domain field to the empty string.

        const char *ts = NULL;
        const char *ds = NULL;

        STAMPTIME_PREPPED(ts_prelock);

        {
            mutex_[tldsRSel_].lock();
            STAMPTIME_PREPPED(ts_postlock);

            if(!firstListLoaded_) {
                had_to_wait = true;
                ProcessingElement &pe = getPE();

                SPLAPPTRC(L_WARN, "Waiting for the initial TLD list to be loaded in. R="<<tldsRSel_, EXTRACT_DOMAIN);

                while(!firstListLoaded_ && !pe.getShutdownRequested()) {
                    // We haven't finished reading in a TLD list on the other port.
                    // We'll just block here forever, waiting for the TLD list.
                    // That means upstream will be blocked as well, or backpressure if there
                    // are threaded ports up there.  Seems like the right thing to do though,
                    // since without a TLD list, we're just going to claim all domains are invalid
                    // anyway.
                    /// @TODO Maybe a parameter on the operator to do this vs just mark them all
                    /// invalid?
                    // Sleep for a ms or so.  Doesn't really matter, just something to keep us
                    // from soaking up a core while we wait.
                    mutex_[tldsRSel_].unlock();
                    pe.blockUntilShutdownRequest(0.001);
                    mutex_[tldsRSel_].lock();
                }

                if(firstListLoaded_) {
                    SPLAPPTRC(L_WARN, "Initial TLD list is loaded.  We can proceed. R="<<tldsRSel_, EXTRACT_DOMAIN);
                }
            }
            STAMPTIME_PREPPED(ts_prekernel);

            STAMPTIME_PREPPED(ts_loopstart);
            for(const char *p = fqdn.c_str(); p && *p; ) {
                // Check the suffix starting at p to see if it is a TLD
                if(tlds_[tldsRSel_]->count(p)) {
                    // Looks like its a TLD!
                    ts = p;
                    STAMPTIME_PREPPED(ts_midloop);
#ifdef MEASURE_TIMINGS_EXTRACTDOMAIN
                    ++labels_searched;
                    lookup_time += TIMEDIFF(ts_midloop, ts_loopstart);
#endif
                    break;
                }

                // Probably not a TLD
                ds = p;
                STAMPTIME_PREPPED(ts_midloop);
                p = ::index(p, '.');
                if(p) {
                    // Move past the dot.  This might put us at the \0 null terminator, but that's ok, and will be handled fine.
                    ++p;
                }
#ifdef MEASURE_TIMINGS_EXTRACTDOMAIN
                lookup_time += TIMEDIFF(ts_midloop, ts_loopstart);
                STAMPTIME_PREPPED(ts_loopstart);
                ++labels_searched;
                scan_time += TIMEDIFF(ts_loopstart, ts_midloop);
#endif
            }
            STAMPTIME_PREPPED(ts_postkernel);

            mutex_[tldsRSel_].unlock();
        }
        STAMPTIME_PREPPED(ts_postunlock);

        if(!ts) {
            // Rather than allow a NULL ptr, set ts (and thus ds, eventually) to the \0 at the end of fqdn.c_str().
            ts = fqdn.c_str() + fqdn.length();
            ds = ts;
            SPLAPPTRC(L_TRACE, "No TLD found.", EXTRACT_DOMAIN);
        } else {
            SPLAPPTRC(L_TRACE, "Found TLD: " << std::string(ts), EXTRACT_DOMAIN);
        }

        if(!ds) {
            // If no domain, just use the TLD itself, since that's apparently what was being questioned, anyway.
            ds = ts;
            SPLAPPTRC(L_TRACE, "No separate domain found.  Just using TLD.", EXTRACT_DOMAIN);
        } else if(ds != ts) {
            SPLAPPTRC(L_TRACE, "Found a separate domain: " << std::string(ds, ts - ds - 1), EXTRACT_DOMAIN);
        }

        if(*ds) {
            // We have something set here, so use the entire domain+TLD for this field
            SPLAPPTRC(L_TRACE, "Setting output field to: " << std::string(ds), EXTRACT_DOMAIN);
            iport$0.set_<%=$outputDomainAttr%>(ds);
        } else {
            // No domain/TLD found.
<% if($blankOnInvalid) { %>
            // blankOnInvalidTLD is set, so force the field to empty (ds points to the \0, so that will work fine)
            SPLAPPTRC(L_TRACE, "Setting output field to blank: " << std::string(ds), EXTRACT_DOMAIN);
            iport$0.set_<%=$outputDomainAttr%>(ds);
<% } else { %>
            // blankOnInvalidTLD is NOT set, so use the full fqdn instead
            SPLAPPTRC(L_TRACE, "Setting output field to full FQDN: " << fqdn, EXTRACT_DOMAIN);
            iport$0.set_<%=$outputDomainAttr%>(fqdn);
<% } %>
        }

        clock_gettime(CLOCK_MONOTONIC, &ts_presubmit);
        submit(iport$0, 0);
        clock_gettime(CLOCK_MONOTONIC, &ts_end);

        time_total_added.fetch_add(TIMEDIFF(ts_presubmit, ts_start), std::memory_order_relaxed);
        time_submit.fetch_add(TIMEDIFF(ts_end, ts_presubmit), std::memory_order_relaxed);

#ifdef MEASURE_TIMINGS_EXTRACTDOMAIN
        ++count_processed;
        count_labels += labels_searched;

        time_preprep += TIMEDIFF(ts_prelock, ts_start);
        time_lock += TIMEDIFF(ts_postlock, ts_prelock);
        if(had_to_wait) {
            time_wait_first += TIMEDIFF(ts_prekernel, ts_postlock);
        }
        time_set_lookup += lookup_time;
        time_find_label += scan_time;

        if(*ds) {
            time_total_kernel_found += TIMEDIFF(ts_postkernel, ts_prekernel);
        } else {
            ++count_no_tld_found;
            time_total_kernel_not_found += TIMEDIFF(ts_postkernel, ts_prekernel);
            count_labels_no_tld_found += labels_searched;
        }

        time_unlock += TIMEDIFF(ts_postunlock, ts_postkernel);
        time_postprep += TIMEDIFF(ts_presubmit, ts_postunlock);

        time_intercall += TIMEDIFF(ts_start, ts_lastexit);

        if(count_processed % (1024*1024*16) == 0) {
            traceStats();
        }

        STAMPTIME_PREPPED(ts_lastexit);
#endif
    }
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {
    SPLAPPTRC(L_TRACE, "entering <%=$myOperatorKind%> process() non-mutating.", EXTRACT_DOMAIN);
    if(port == 1) {
        const IPort1Type& iport$1 = tuple;

        SPLAPPTRC(L_TRACE, "Process non-mutating, port 1.", EXTRACT_DOMAIN);

        AutoPortMutex amW(mutex_[tldsWSel_], *this);

        tlds_[tldsWSel_]->insert(<%=$inputPort1CppName%>.get_<%=$tldAttribute%>());

        return;
    }
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port) {
    SPLAPPTRC(L_TRACE, "entering <%=$myOperatorKind%> process() punctuation.", EXTRACT_DOMAIN);

    if(port == 1) {
        if(punct==Punctuation::WindowMarker) {
            SPLAPPTRC(L_WARN, "<%=$myOperatorKind%> process() punctuation: window.", EXTRACT_DOMAIN);

            // Take both the R & W mutexes so we can close out the current filter list
            // and swap lists atomically. This is the very uncommon case
            // so the locking overhead is not important.
            // However, we first grab just the writer's mutex,
            // to avoid slowing down tuple processing.
            mutex_[tldsWSel_].lock();

            // Ok, all ready to do the swap, so grab the reader mutex as well now.
            mutex_[tldsRSel_].lock();

            firstListLoaded_ = true;

            SPLAPPTRC(L_WARN, "<%=$myOperatorKind%> process() sending Window punctuation out port 0", EXTRACT_DOMAIN);
            submit(Punctuation::WindowMarker, 0);

            size_t tmpList = tldsWSel_;
            tldsWSel_ = tldsRSel_;
            tldsRSel_ = tmpList;

            // Drop the lock for the _new_ reader's tld set (was the writer's tld set, when locked)
            mutex_[tldsRSel_].unlock();

            // At this point, we've already swapped, so tldsWSel points to the old set we were using,
            // which should now be cleared before new stuff goes in it.
            tlds_[tldsWSel_]->clear();

            // Finally, drop the new writer's tld set lock (was the reader's tld set, when locked)
            // so new tld files can be read in (eventually)
            mutex_[tldsWSel_].unlock();

        } else if(punct==Punctuation::FinalMarker) {
            SPLAPPTRC(L_WARN, "<%=$myOperatorKind%> process() punctuation: final.", EXTRACT_DOMAIN);
        }
    }
}


<%SPL::CodeGen::implementationEpilogue($model);%>

